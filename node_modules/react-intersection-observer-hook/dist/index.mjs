import{useCallback as O,useRef as u,useState as R}from"react";function p(){let i=new Map;function l({root:s,rootMargin:t,threshold:c}){let r=i.get(s);r||(r=new Map,i.set(s,r));let v=JSON.stringify({rootMargin:t,threshold:c}),o=r.get(v);if(!o){let e=new Map;o={observer:new IntersectionObserver(y=>{y.forEach(k=>{e.get(k.target)?.(k)})},{root:s,rootMargin:t,threshold:c}),entryCallbacks:e},r.set(v,o)}return{observe:(e,b)=>{o.entryCallbacks.set(e,b),o.observer.observe(e)},unobserve:e=>{o.entryCallbacks.delete(e),o.observer.unobserve(e)}}}return{getObserver:l}}var C="0px",d=[0],H=p();function E(i){let l=i?.rootMargin??C,s=i?.threshold??d,t=u(null),c=u(null),r=u(null),[v,o]=R(),e=O(()=>{let n=t.current;if(!n){o(void 0);return}let a=H.getObserver({root:c.current,rootMargin:l,threshold:s});a.observe(n,f=>{o(f)}),r.current=a},[l,s]),b=O(()=>{let n=r.current,a=t.current;a&&n?.unobserve(a),r.current=null},[]),y=O(n=>{b(),t.current=n,e()},[e,b]),k=O(n=>{b(),c.current=n,e()},[e,b]);return[y,{entry:v,rootRef:k}]}var I=E;import{useState as m}from"react";function h(i){let[l,s]=I(i),t=!!s.entry?.isIntersecting,[c,r]=m(t);return t&&!c&&r(!0),[l,{...s,isVisible:t,wasEverVisible:c}]}var g=h;export{I as useIntersectionObserver,g as useTrackVisibility};
